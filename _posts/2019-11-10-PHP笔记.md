---
layout: post
title: 'php基础语法笔记'
date: 2019-11-06
categories: test
tags: php
---

## 基础

1. php是什么
    术语：超文本预处理器
      	用一句话概括：一种开发动态网站的服务器脚本语言

2. php文件存放位置

   ​        wampserver环境的根目录         www目录
   ​	phpstudy环境的根目录		www目录
   ​	xampp环境的根目录			htdocs目录
   ​	apache原生环境的根目录		htdocs目录

3. 如何运行php文件
       开启集成环境
        打开浏览器
        地址栏输入localhost
        点击需要运行的php文件
   注意：若目录下拥有index.php或者index.html文件，那么在打开该文件夹时还自动访问index文件

4. 定界符
       \<?php

   ​              ?\>
   ​	注意php代码只有在定界符内才能正常运行，负责原样输出
   ​	在定界符之外是可以直接书写html代码的
   ​	再定界符之内只有通过echo 来输出内容

5. 常用输出

   ​	echo “内容”
   注意：
   ​	内容可以是数字，字母，标点符号，汉字，html代码
   ​	若内容是纯数字可以不写引号
   ​	若php定界符中只有一个echo则可以简写为\<?= '内容'?\>

6. php字符集/编码

   ​	header("content-type:text/html;charset=UTF-8");

7. 注释

   ​	单行注释   //  或者#
   ​	多行注释  /**/

8. 基本语法

   ​	每一条命令均以;号结尾
   ​	最后一条命令可以省略分号

9. 查看php环境

   ​	phpinfo();

## 变量

1. 变量：一个存储任意数据的变量

2. 格式：

   ​	$变量名 = 值

3. 注意点：

   1. 变量名前面一定要加$符
   2. 变量名由数字、字母、下划线组成；但是不能以数字开头
   3. 变量名是区分大小写的
   4. 没有值的变量都会认为是未定义的变量

4. 变量技巧

   1. 可变变量：将一个变量的值 作为另一个变量的名去使用
       例如：
         		$name = 'abc';
         		$abc = '123';
         		echo $$name    输出的结果为123
   2. 传值：让一个变量的值等于另一个变量的值
         例如：
                       $a = 100;
                        $b = $a;
                         $b = 200;
                         echo $b； 输出结果为200
                         echo $a； 输出结果为100
   3. 传址：把一个变量的值的存储地址让给另一个变量
             例如：
                       $a = 100;
                       $b = &$a;
                       $b = 200;                   
                       echo $a;   输出结果为200
                       echo $b;   输出的结果为200

   ## 常量

   定义：经常不变的量

   格式：

   ​	const	常量名 = 常量值

   ​	define（常量名，常量值，bool）
   ​							true 	不区分大小写
   ​							false	区分大小写  默认

   注意点：

   ​	1、严格区分大小写

   ​	2、常量不能重新赋值

   ​	3、常量不能重新定义

   预定义常量

   ​	PHP_INT_MAX		最大整型

   ​	M_PI				圆周率

   ​	PHP_VERSION		php当前版本

   ​	PHP_OS				php的所在的操作系统

   魔术常量

   ​	\_\_FILE__		获取盘符地址
   ​	\_\_DIR__		获取当前目录
   ​	\_\_LINE__		获取行号

## 进制转换

|          |   基数    | 前缀 |
| :------: | :-------: | :--: |
|  二进制  |    0-1    |  0b  |
|  八进制  |    0-7    |  0   |
|  十进制  |    0-9    |  无  |
| 十六进制 | 0-9 + a-f |  0x  |

任意进制转换为十进制公式：基数 * 进制数^开次方
						个位开0次方
						十位开1次方
						百位开2次方
						千位开3次方
						以此类推......

十进制转换为任意进制：将十进制的数 除以 进制数  倒取余数

## 数据类型

### 标量类型

#### 整型	

int    所有的整数
最大值：PHP_INT_MAX  来获取
  		echo  PHP_INT_MAX；
  		php7.0-  	最大值为21亿
  		PHP7.0+		最大值为	9223372036854775807
  	is_int()函数来判断是否为int数据类型

#### 浮点型    

 float     所有的小数
    值得写法：所有的小数
                       科学计数法 xEy 表示x乘以10的y次方

​	通过is_float()函数来检测是否为浮点数

有效位数：
		从左往右，第一个非零数字开始计算，一共14位
浮点运算：
		浮点数在转换为二进制时时不精确的
		不要用浮点数左等价运算，因为在计算机中0.1+0.2 !=  0.3.

#### 布尔型                 

bool

- 值得写法：
  ​			true
  ​			false      两种极端的状态

- 作用
  ​		当无法用数值来表达时，可以用状态来表示
  ​		常用于 比较和判断等场合

  ​		通过is_bool()函数来判断是否为布尔型

- 等价值：
  ​		有七种值是于false等价，其余都与true等价
  ​		1.false
  ​		2.0
  ​		3.0.0
  ​		4.''和‘0’ 	空字符串和零字符串
  ​		5.[]		空数组
  ​		6.null	空数据类型
  ​		7.未定义的变量

#### 字符串类型

​	值得写法：
​		单引号
​		双引号
​		heredoc结构

​	heredoc结构写法
​		<<<开始定界符



​		结束定界符；
​	注意：

​		heredoc开始定界符后面不能有任何字符，包括空格
​		 heredoc结束定界符前后都不能有任意字符，包括空格
​		开始定界符必须和结束定界符一致
​		最大长度2G

​	通过is_string()函数来判断是否为字符串类型

​	通过is_scalar()函数来检查是否为标量

​	通过is_numeric()来判断是否为数字字符串
​			只有数字or只包含数字的字符串都是

单双引号的区别：

​			单引号：不解析变量和转义字符，速度快

​			双引号	解析变量和转义字符，速度慢

单引号和双引号的共同特性：支持互插，不能自插。

### 复合类型

#### 数组类型

array  数组

定义：一个可以容纳多个数据的容器

值得写法：

​	$变量名[] = 变量值

​	$变量名 = [值1，值2，值3]

输出数组：

​	var_dump(数组)

​	print_r(数组)

数组形成

​	array（

​		键  =>  值
​		键  =>  值
​		键  =>  值

​	）
​	键的别名：索引，下标，偏移量。

数组不写键名是，默认的键为从零开始的数字

#### 对象

定义：一切皆为对象

获取对象：

​	变量 = new stdClass

检测是否为变量：is_object(变量名);

### 特殊类型

#### 资源

定义：所有的文件都是资源

获取资源

​	变量 = fopen（'文件地址','r'）;

检测是否为资源：is_resource();

#### 空数据类型

值得写法：null

作用：占位

有三种情况的值直接显示为null

​	1.直接赋值
​	2.为定义的变量
​	3.被删除的变量        unset()：删除数据

### 数据类型的转换

#### 自动转换

​	算数运算符可以让布尔类型和字符串类型的数据转换为整型或者浮点型

#### 强制转换

##### 临时转换

1. (要转换的类型)变量：
   		类型支持：int	float	bool	string	array	object	

2. 通过函数来进行临时转换

   intval(变量)				转换为整型
   boolval(变量)				转换为布尔型
   floatval(变量)				转换为浮点型
   strval(变量)				转换为字符串型

##### 永久转换

​	settype(变量，‘类型’)；

## 运算符

### 算数运算符

 算数预算符有：+ - \* / % ++ --

%取模的结果正负取决于除数的正负

%取模结果的范围

​		结果范围 0  ~ n		%(n+1)
​		结果范围 m ~ n		%(n-m+1) + m

a++		先返回值，再++；	a--	先返回值，再--
++a		先++，再返回值；	--a	先--，再返回值

### 拼接运算符

拼接运算符：小数点（英文）

作用：拼接变量与变量；拼接变量与字符串

### 赋值运算符

赋值运算符有：=   +=   -+    *=     /=     %=      .=

= 	先算等号右边的，再算等号左边的

​	等号左边不能做运算

+=           a += b 	==>		a = a+b

-+	-=	\*=	/=	%=	.=   于上同理

### 比较运算符

所有的比较结果都是 bool

​			<  <= 
 			>  >=
 			 ==   		两边的值相等
​			===     		两边的值相等，并且数据类型也一致	（全等）	
​			!=    			两边的值不相等
​			!==			只有全等时为true，其余都为false

### 逻辑运算符

|        |    符号    |            运算规则            |
| :----: | :--------: | :----------------------------: |
| 逻辑与 | && 或 and  | 两边为真即为真，一边为假即为假 |
| 逻辑或 | \|\| 或 or | 一边为真即为真，两边为假即为假 |
| 逻辑非 |     ！     |       真既是假，假即是真       |

注意点：

* 纯逻辑运算：先算与，再算或
* 赋值逻辑运算：画方框 
* 单词逻辑的与或的优先级要比 = 低

### 三元运算符

表达式？ true环境：false环境；

## PHP中常用输出方式

1. echo
   * 支持类型：int，string，float，resource;
   * 语法结构
   * 可以输出多个变量，用逗号隔开；
   * 多用于普通输出一行
2. print
   * 支持类型：int，string，float，resource；
   * 语法结构
   * 只能输出一个变量
3. print_r
   * 支持类型：int，float，string，array，object，resource；
   * 函数
   * 数组打印数量，理论上无上限，实际受内存限制；
   * 适合大量数据输出
4. var_dump
   * 支持所有类型
   * 函数
   * 数组打印上限为128个
   * 常用于测试查看详情信息

## 基本函数

empty()
	检测一个变量是否为空
	为空时返回true   （只要与false等价，即为空）
	非空时返回false

isset()
	检测一个变量是否设置
	设置则返回true
	未设置则返 回false （值等于null，即为未设置）

unset()
	删除一个变量

## 流程控制

### 顺序结构

代码通过从上往下依次执行，就是顺序结构

### 分支结构

#### if语句

​	单向分支：
​			if(条件表达式)  1行代码块；
​			if（条件表达式）{

​				代码块；
​			}

​	多向分支：
​			if(条件表打式1){

​				true环境1；
​			}elseif(条件表打式2){

​				true环境2；
​			}else{

​				false环境；
​			}
​			

​	巢状分支：
​			if(条件表打式1){

​				if(条件表打式2){

​					true环境；
​				}else{

​					false环境；	
​				}

​			}else{

​				false环境；
​			}

条件表打式：只看最终结果是否为true或者false；

代码块:可0行，可一行，可多行。

if分支适合范围型判断，也可以用于定值判断

#### switch语句

switch   分支适合用于定值判断

switch(标志){

​		case 标志1：
​				代码块；
​				break；

​		case 标志2：
​				代码块；
​				break；
​			......
​		default:
​				代码块；

}

一旦执行到break时，立马跳出switch分支

匹配不到标志是，则执行default区域

### 循环

循环三要素：

​		1.初始值
​		2.循环条件
​		3.循环增量

#### while循环

先判断再循环

   初始值

while（循环条件）{

​		代码块（增量）
}

#### dowhile循环

先执行一次代码，在判断

初始值

do{

​	代码块(增量)
}while(循环条件);

#### for循环

for(初始值;循环条件;循环增量){

​	代码块；

}

效率：while和do while的执行效率高，for比较方便

注意：
	循环条件最终结果为true时，才认为条件成立

条件可能是：赋值，比较，逻辑。

###  html 与 for和if 混合写法

#### for 与 html 混合写法

<? php for(): ?>

​	html源代码

<?  php endfor  ?>

#### if与html 混合写法

<? php  if():?>

​	html 源代码

<? php endif ?>

-------------------------------

<?php if(): ?>

​	true环境代码

<?php else:?>

​	错误环境代码

<?php endif?>

<hr>

<?php if():?>

true环境代码1

<?php elseif():?>

true环境2代码

<?php else?>

false环境代码

<?php endif ?>

## 函数

### 函数的定义

定义: 将一段代码组装城一个完整的功能

分类:

- 内置函数:官网开发的(背记)
- 自定义函数: 自己开发的功能(根据显示需求变化而变化)

自定义函数(定义函数)

function 函数名([参数1,参数2,....])

{

代码块

}

注意: 

- 函数不调用是不会自动执行
- 不调用函数仍会解析里面的语法
- 定义函数位置和调用函数先后位置无所谓
- 函数可以互相调用

5.调用函数

函数名()

函数名(参数)

### 函数名

- 组成:
  - 由数字字母下划线组成,但不能以数字开头
- 函数名大小写
- 命名形式:
  - 一个单词小写字母就可以
  - 两个单词以上常使用下面的命名方式:
    - 驼峰式: 从第二个单词开始,首字母大写
    - 帕斯卡: 每个单词的首字母,都大写
    - 匈牙利: 每个单词之间用下划线 隔开
- 函数名不能重复
- 函数名取得要有意义

### return 

- 作用: 立马中断函数,将值 带回到'调用函数'的地方
- 返回类型: 返回任意类型
- 如何一次性返回多个值: 将多个值存储在一个数组里面

### 函数参数

1.分类

- 形参: 定义函数时给的参数;
- 实参: 调用函数时给的参数;

2. 参数数量

- 实参个数  = 形参个数
  - 接收参数时,是按照先来后到的顺序接收的
- 实参个数 > 形参个数
  - 多余的参数舍弃
- 实参个数 < 形参个数
  - 参数依旧按照 先来后到的顺序接收,
  - php5  多余的形参,默认当作未定义变量来处理
  - php7 多余的形参 , 直接报错, 中断程序
- 当参数个数不确定时,通过函数来表达含义
  - func_get_args();接收所有的实参,以数组形式接收
  - func_get_arg(); 接收数组实参中键为2 的值
  - func_num_args();获取实参的总个数
- 形参默认值
  - 实参个数 < 形参个数时
    - 多余的形参默认报错,or 当作未定义变量
    - 多余的形参采用默认值

### 变量的作用域

1.全局变量: 在函数区域外定义的变量, 即为全局变量

2.局部变量: 在函数之内定义的变量,即为局部变量

3.静态变量: 比较特殊的局部变量,在函数结束时,不会立刻从内存中消失,当再次调用此函数时,静态不会重新初始化,会直接使用上一次的静态值

2.特性:

- 全局变量不能直接在局部变量中使用

- 局部变量不能直接在全局环境中使用

- 在局部环境中,全局变量通过$GLOBALS 超全局数组,可以在局部环境中使用
- 在局部环境中,局部变量通过 global 可以在全局环境中使用

3.注意

​	所有的普通全局变量, 是可以在全局环境中任意使用

​	函数一旦定义,就会形成局部作用域,函数内的所定义变量, 一旦 脱离局部作用则会立马从内存中消失

​	函数一旦结束,里面的所有局部变量,也会立马从内存中消失

### 常量作用域

1.没有作用域,哪里都可以直接用

2.在函数内,无法通过const 定义常量,可以通过define 定义,但不推荐

### 函数技巧

1.可变函数: 将一个变量的值 作为另一个函数名来使用

2.引用函数: 将一个实参的内存地址 传给形参,形参和实参共享同一个内存

    新手函数基本步骤
    1. 函数名
    2. 参数
        * 个数
        * 默认值
    3. 核心功能
        没有的数据先模拟，保证核心功能能实现
    4. 补充
        将所有的模拟数据， 全部做活
    5. 返回值        
## 数组的详细用法

### 分类

- 索引数组: 键为 int;
  - 索引数组的特性
        下标从当前最大下标开始,自动+1
- 关联数组: 键为 string
- 混合数组: 键既有int 又有 string

### 形式

array 键1=> 值1,

​	   键2=> 值2,

键值对,只要有一个键,必然有一个值

如果没有键,必然没值

### 键

别称: 下标,索引,偏移量

键的类型: int 或 string

- 键从未指定,默认从0开始,依次递增
- 键部分指定,空键会从"已有"的最大int键+1
- 等价键:
  - 纯数字 = 纯数字字符串
  - false = 0 = 0.0 = '0' =  0.x;
  - true = 1 = 1.0= '1' = 1.x
  - null = '' 未定义变量
- 非法键: 
  - 数组
  - 对象
  - 资源
- 格式: 
  - $变量名[键] = 值;
  - $变量名 = [键1=>值1,键2=>值2,键3=>值4]

### 多维数组

定义: 数组中嵌套数组

一维
   	 array
       		 键 => 值

二维
	array
		键 => array

array
	键1 => array1
	键2 => array2
	键3 => array3

三维
array
	键 => array
		键 => array   

### 遍历数组

1.索引数组: 只能遍历有规律的数字键

2.指针数组: 啥数组都能遍历,固定从第一个键开始一直获取,知道获取结束

索引遍历:

​	只能遍历有规律的数字键 数组1

指针遍历:

​	无规律的数字键 

​	foreach(数组变量 as 键=> 值){

代码块

}

​	如果不需要键,则省略键

​	foreach(数组变量 as 值){

代码块}

###  指针函数

1.key() 获取当前指针所指向的键

2.current() 获取当前指针所指向的值

3,next() 将指针下移一位  

4.prev() 将指针上移一位

5.reset() 将指针重置到第一位

6.end() 将指针重置到最后一位

7.each()

- 返回数组中 当前的键/值对,并将数组指针 向前移动一步

   - 如果超过了 数组元素的个数, each 会返回一个`false`

   - 返回值是由`四个元素`组成的数组:

        - 元素的键名为 `0/1/key/value`

        - `0和key`  对应的是 `键名`,
        - `1和value`对应的是 元素的`值`



- list()
    - 把数组中的值 赋值给一些指定的变量.
    - PHP 5 里，list() 从最右边的参数开始赋值；
    - PHP 7 里，list() 从最左边的参数开始赋值。
    - 参数为要指定的变量
    - 仅用于`索引数组`,且`下标从0开始并连续`

### 字符串数组

字符串在一定意义上可以当作 索引数组来操作

数字,字母,标点占1个字节,读取也是一个一个读取

汉字占3个字节,必须连续输出3个才能读取一个字(顺序不能随便写)

### 预定义数组

$GLOBALS 

- 超全局数组,里面存储了所有全局可用的变量

$_GET

- 接收所有以 get 方式传递过来的值
  - form中method=get
  - a链接的参数

$_POST

- 接收所有以post 方式传递过来的值
- form 中method =post

$_REQUEST

- 同时接收get ,post和cookie

$_FILES

- 专门用于接收上传的文件

  - form 表单enctype = multipart/form-data
  - form 表单的method =post
  - file 表单的name 必须要有值

- 多文件有几个必要条件

  - file 表单的mutipe 必须有
  - file 表单的name 值后面必须要加[]

- file表单的name 值

  - [abc] => Arry

    (

    上传的文件名

    [name] => 1.jpg

    上传文件类型

    [type] => image/jpeg

    上传文件的临时文件

    [tmp_name] => D:/s/s/

    上传的错误号: 0 没有错

    ​			非0 有错

    [error] => 0

    上传的文件大小 单位: B 字节

    [size] => 1020093

    )

- $_COOKIE    存储浏览器里面的cookie
      $_SESSION   存储服务器里面的session

      $_SERVER    含有了主机, IP, 参数, 脚本, 终端, 浏览器版本...
                  HTTP_HOST   主机地址
                  HTTP_USER_AGENT    终端, 浏览器半杯
                  HTTP_REFERER       上一级来源地址
      
                  REMOTE_ADDR        客户端的IP地址
                  REQUEST_METHOD     请求方式
                  QUERY_STRING       请求参数
                  REQUEST_URI        请求地址(含参数, 比较完整)
      
                  SCRIPT_NAME        当前脚本地址( 根地址 )
                  SCRIPT_FILENAME    当前脚本地址( 盘符地址 )

## 正则表达式

- 定界符
  - / / 或者##
- 原子
  - 可见原子
    - 肉眼可见的原子符号例如a-z,0-9,A-Z
  - 不可见原子
    - 例如换行符,回车,制表符,等等
- 元字符
  - |  匹配两个或多个分支选择
  - [  ] 匹配方括号中的任意一个原子
  - [^ ]匹配除了方括号的原子之外的任意字符
  - **.**  **匹配除换行符之外的任意字符**
  - **\d**  **匹配任意一个十进制数字，即[0-9]**
  - **\D** 匹配任意一个非十进制数字即[^**0-9]**
  - **\s  匹配一个**不可见原子，即[\n\t\r]
  - **\S**  **匹配一个可见原子，即[^**\n\t\r]
  - **\w** **匹配任意一个数字、字母或下划线，即[_0-9a-zA-Z]**
  - **\W**  **匹配任意一个非数字、字母或下划线，即[^**_0-9a-zA-Z]
  - **{n} 表示前面的原子恰好出现n 次**
  - **{n,}表示其前面的原子最少出现n 次**
  - **{n,m}表示前面的原子最少出现n次,最多出现m次**
  - ***前面的原子 匹配0次,1次或多次**
  - **+匹配1次或者多次其前的原子,即[1,]**
  - **? 匹配0次或者1次其前的原子,即{0,1}**
  - **^ 匹配字符串开始的位置**
  - **$ 匹配字符串结尾的位置**
  - **()匹配其中的整体为一个原子**
  - **(|)匹配其中的两个或更多的选择之一.分隔多选一模式**

- 模式修正符
  - 贪婪模式
    - .* 匹配结果存在歧义1时取其长(默认)
  - 懒惰模式
    - U 匹配结果存在歧义的取其短,贪婪与懒惰互换
  - 忽略空白
    - x 匹配结果忽略空白
  - 大小写匹配
    - i 匹配结果不区分大小写
  - 中文支持
    - u 一个汉字 当成1个原子,默认情况下,一个汉字当三个原子
      - \x{4e00} ~ \x{9fa5}    在编码表中, 汉字的范围
  - 支持换行的 s

- **匹配模式**
  - 1.单次匹配preg_match(正则,内容[,匹配结果])
    - 返回值:匹配次数,成功的次数,成功:1,失败:0
- **全部匹配**
  - preg_match_all(正则,内容[,匹配结果])
  - 返回值: 匹配的次数成功:=>1,失败:0

#### 正则替换

- 函数: preg_replace(正则,替换值,内容);
  - 返回值: 替换之后的内容

**例如**:

$str = '二手车买卖, 一个卖家准备卖劳斯莱斯, 一个买家借着试车的名义, 直接开走了一SB';

// 准备 敏感词数组
$words = ['一个', '买卖', '劳斯莱斯', 'SB'];

// 循环 敏感词
foreach( $words as $v ){
    // 1. 统计 $v 有几个字符
    $count = preg_match_all('/./u', $v);

    // 2. 重复 count次 *
    $star = str_repeat('*', $count);
    
    // 3. 替换 敏感词
    $str = preg_replace("/{$v}/", $star, $str);
}

echo $str;

#### 正则分组: 模式单元

- 在匹配结果中
  - 下标为0,就是整个正则匹配的结果
  - 下标为1,就是第一个() 匹配的结果
  - 下标为2,就是第二个()匹配的结果
  - 以此类推
- 后向引用:
  - 后面的引用前面的人,保证两处的值一致的
  - \1会与第一个()匹配的结果一致
  - \2会与第二个()匹配的结果一致
  - 以此类推
- 取消分组:
  - (?:正则)  该小括号不会参与正则分组

​			

### 正则过滤

函数: preg_grep(正则,数组)

返回值: 过滤之后的数组

##  时间处理

Unix时间戳   单位s

- 获取当前时间戳

  - time()1970~现在 的秒数

- 格式化时间戳

  - **date(格式[,时间戳])**

  - **格式的写法**:

    - 非字母随便写,都是原样输出的

    - 字母区分大小写

    - Y 4位年份 year

    - y 2位年份 

    - m  月份  month

    - d 天   day

    - H 24 小时 hour

    - h 12小时 

    - a am/pm

    - i 分  minute

    - s 秒  second

      其余字母,参考手册

- 时区

  - 默认时区: UTC 世界标准时间,格林威治时间
  - 中国时区: PRC
  - date_default_timezone_set()设置时区
  - date_default_timezone_get()获得时区

#### mktime(时,分,秒,月,日,年)

创建一个时间点,返回值:时间戳

#### strtotime(字符串)

返回值: 时间戳

#### sleep()

睡眠/延迟时间

#### microtime()

微秒的时间

## PHP 错误处理

####  常见错误

php程序的错误一般发生在以下3种情况:

1.语法错误

- 最常见,也是最容易修复
- 阻止脚本的执行

2.运行时错误

- 比较常见, 比较容易修复
- 阻止脚本的执行,,也有不阻止脚本执行的

3.逻辑错误

- 最麻烦,不容易修复
- 不会报错,也不会阻止脚本的执行

运行时错误

1.error  致命错误,阻止脚本的执行

2.warning 警告错误,不会阻止脚本的执行

4.parse 语法错误

8.notice 提示错误,不会阻止脚本的执行

#### 错误处理的方式

目的:

- 项目测试/开发中,所有的错误必须全部显示
- 项目上线中,屏蔽所有的错误
- 
- 以上的错误屏蔽是无法屏蔽语法,error级错误

屏蔽1:

- 错误抑制符@

屏蔽2:(推荐)

- 函数: error_reporting(参数)
- 从调用该函数之后,产生屏蔽错误的效果
- 所以该函数的位置一般在头部
- 作用域: 当前文件
- 参数:不加引号
  - 0 屏蔽所有错误
  - E_ALL 显示所有的错误
  - E_WARNING 显示WARNING 级错误
  - E_NOTICE显示 E_NOTICE级错误
  - E_ALL ^E_WARNING 显示所有的错误除了WARNING级错误
  - E_ALL & ~ E_WARNING 显示所有的错误除了WARNING级错误
  - E_ALL &~E_NOTICE 显示所有的错误除了NOTICE级别错误

屏蔽3:vv  

- 函数:
  - ini_set() 		临时修改配置文件
  - 作用域: 当前文件

- 配置:
  - display_errors = ON /1 开启错误提示
    - ​			Off /0关闭错误提示
  - error_reporting = 值 与屏蔽2的常量参数一样

屏蔽4:

- 修改配置文件 php.ini
- 作用域:整个服务器,慎用
- 位置: wamp/bin/apache/apachex.x.x/bin/php.ini
- 配置1:
  - display_errors = On/Off
  - error_reporting = 常量
- 注意: 
  - 修改任意的配置,只有在重启服务后,才能起作用
  - 配置文件以分号开头,代表的是注释,一般不需要改动

#### 自定义错误

1.自定义错误

- trigger_error(报错信息,错误类型)
  - E_USER_ERROR 自定义致命错误
  - E_USER_WARNING 自定义警告错误
  - E_USER_NOTICE 自定义提示错误

2.错误日志

- error_log(s1,s2,s3)
- 参数:
  - s1:报错信息
  - s2:  错误处理类型 3(写日志)
  - s3: 目标文件

#### 逻辑错误

最麻烦的地方:既不会报错,又不会终止脚本的执行

如何缩小错误范围:

- 断点法: 通过 die 主动中止程序,并且在die之前输出相关的数据,从而判断

- 注释法: 利用注释不被解析的特性来判断


## 文件

### 文件属性

1.分类:

- 文件 file
- 文件夹,目录 dir

2.获取文件类型

- 函数: filetype()
- 返回值: file dir

3.获得文件大小

- 函数: filesize()
- 返回值: bool

4.检测文件是否存在

- 函数: file_exists()
- 返回值: Bool

5.检测文件的创建/修改/访问时间

- 函数: filectime()
- 函数: filemtime()
- 函数: fileatime()

6.检测文件是否可读可写

- is_readable()
- is_writeable()
- 返回值: bool

### 文件的路径函数

1.获取文件的目录路径

- 函数: dirname()

2.获取文件的文件名

- 函数; basename()

3.解析盘符式路径

- 函数: pathinfo()
- 返回值: array

4.解析网络式路径

- 函数: parse_url()
- 返回值: array

5.提取字符串方法

- strtok()         保留开头~第一个分隔符之间的内容
- strrchr()        保留最后一个分隔符~末尾之间的内容 
- strstr()         保留第一个分隔符~末尾之间的内容
- strchr()         保留第一个分隔符~末尾之间的内容

### 目录/文件相关函数

1.opendir()打开一个目录,返回资源

2.readdir()读取一个资源,返回资源名

3.closedir() 关闭一个资源

4.copy(复制谁,复制到哪)

5.is_file() 检测是否为文件,返回值: bool

6.is_dir() 检测是否为目录,返回值: bool

7.rename(剪切谁,剪切到哪儿去)剪切文件

8.touch ('文件名地址')创建文件

9.unlink ('文件名地址')删除文件

10.mkdir('目录地址')创建目录

11. mkdir('目录地址',0777,true)创建多层目录
12. rmdir('目录地址')只能删除空目录

### 文件加载include

**格式**: 

- include "文件地址"

- include ("文件地址")

**注意**:

- include 是什么时候执行,才能什么时候加载
- include 可以重复加载,通过include_once避免重复加载
- include 的加载路径支持相对路径,盘符式路径,不支持网络式路径,根路径
- include 如果加载地址出错,不会终止程序的执行

### 文件依赖require

格式: require"文件地址"

注意:

* require 是什么时候执行, 才什么时候加载
* require 可以重复加载, 通过 require_once 避免重复加载
* require 的加载路径支持相对路径, 盘符式路径, 不支持网络式路径, 根路径
* (重点) require 如果加载地址出错, 会终止程序的执行

### 文件加载 HTML

用PHP文件加载HTML 文件,那么该HTML文件支持PHP代码

单纯的执行HTML 文件,那么该HTML文件不支持PHP代码

### 文件内容

1.向文件赋予内容

- 函数: file_put_contents(文件地址,内容)
- 先将文件大小截为0,再重新写入内容

2.向文件获取内容

- 函数: file_get_contents(文件地址)

3.打开一个文件,返回文件资源

- fopen (文件地址,打开模式)
- 返回值: 文件资源
- 打开模式:
  - r 只读.指针默认指向开头,如果文件不存在,则报错
  - w 只写,指针默认指向开头,如果文件不存在,则自动创建如果文件已存在,则先将文件大小截为0,在写入
  - a   追加, 指针默认指向末尾, 如果文件不存在, 则自动创建
  - +增强, 配合r, w, a, 让他们同时具有读写功能

4.读取文件资源

- fread(资源,字节)

5.写入文件资源

- fwrite(资源,内容)

6.关闭一个文件资源

- fclose(资源)

### 文件上传

#### 1.前端的必要条件

- file 表单的name 必须要有值
- form 表单的method = post
- form 表单的enctype = multipart/form-data

#### 2.PHP通过$_FILES 来接收上传的文件

   array (size=1)
          file表单的name值
          'photo' => 
                    array (size=5)
                      上传的文件名
                      'name' => string '3.jpg' (length=5)

                      上传的文件类型
                      'type' => string 'image/jpeg' (length=10)
    
                      临时文件
                      'tmp_name' => string 'D:\wamp\tmp\php9725.tmp' (length=23)
    
                      错误号:  只有0才是成功, 其余都是上传失败
                      'error' => int 0
    
                      上传文件的大小
                      'size' => int 189294
#### 上传文件的条件限制

前端限制: name = "MAX_FILE_SIZE" value="自定义大小 字节"

协议限制: php.ini 配置文件

- 位置:  wamp/bin/apache/apachex.x.x/bin/php.ini
- 配置:  post_max_size = 8M	

服务器限制: php.ini

- 配置: upload_max_filesize = 2M

#### 后端上传文件的检测

// 1. 检测 error
    $key =  key( $_FILES );
    if( empty($key) ){
        echo '您上传的文件过大';
        echo '<meta  http-equiv="refresh"  content="2;url='.$_SERVER['HTTP_REFERER'].'" >'; die;
    }

    $error = $_FILES[$key]['error'];
    if( $error != 0 ){
        switch($error){
            case '1': echo '您上传的文件过大'; break;
            case '2': echo '您上传的文件过大'; break;
            case '3': echo '上传中断, 请检查您的网络'; break;
            case '4': echo '请选择要上传的文件'; break;
            case '6': echo '服务器繁忙, 请稍后再试'; break;
            case '7': echo '服务器繁忙, 请稍后再试'; break;
        }
        echo '<meta  http-equiv="refresh"  content="2;url='.$_SERVER['HTTP_REFERER'].'" >'; die;
    }

// 2. 检测 post协议
    // is_uploaded_file( 临时文件 )
    $tmp = $_FILES[$key]['tmp_name'];
    if (  !is_uploaded_file( $tmp )    ) {
        echo '非法上传';
        echo '<meta  http-equiv="refresh"  content="2;url='.$_SERVER['HTTP_REFERER'].'" >'; die;
        // 重定向会将页面跳转至 指定页面, 但是后面的代码会依旧执行, 为了防止这种情况, 一般都会在 跳转代码后面补die
    }

// 3. 检测 文件类型
    $type = strtok($_FILES[$key]['type'], '/');
    $allowType = ['image'];

    if( !in_array($type, $allowType) ){
        echo '您上传的类型不符合要求';
        echo '<meta  http-equiv="refresh"  content="2;url='.$_SERVER['HTTP_REFERER'].'" >'; die;
    }

// 4. 设置新的文件名 (唯一)
    // 20190813xxxxxxxxxx.jpg

    // 扩展名
    $suffix = strrchr($_FILES[$key]['name'], '.');
    
    // 文件名
    // uniqid()    基于微秒产生一个唯一id, 适合低频率
    // uuid()      号称千年之内都不会重复的id, 适合高频率
    $name = date('Ymd').uniqid();
    
    // 新的完整文件名
    $filename = $name.$suffix;

// 5. 设置新的存储目录
    // Upload/2019/08/13
    $dir = 'Upload'.date('/Y/m/d/');
    
    if ( !file_exists($dir) ) {
        mkdir($dir, 0777, true);
    }

// 6. 移动文件
    // move_uploaded_file( 临时文件, 新的文件路径  ) 
    if ( move_uploaded_file( $tmp , $dir.$filename )) {
        echo '上传成功';
    }else{
        echo '上传失败';
    }

 ?>

### 文件下载

1.前端设置:

- 写入a链接
  - 格式:  <a href="文件地址?文件名字的参数"> 种子1号: 班长的裸照 </a>

2.后端设置:

- 接收参数:$变量名 = $_GET['前端的a链接参数名']
- 下载路径: $b = 路径.$变量名
- 准备下载后的文件名:
  - $扩展名 = strrchr($name,'.');
  - $文件名 = strtoupper(str_shuffle(md5(mt_rand()))).$扩展名;
  - header('content-Disposition:attachment; filename='.$文件名);

- 读取文件下载路径
  - readfile($b);





# 面向对象

## 谈谈你对面向对象的理解?

- 所谓面向对象,就是一种oop编程思想 万物皆对象, 把具体事物的属性和功能封装在一个类里面,使其模块化,能够被重复使用这就是面向对象的封装特质,除此之外我们还有继承,多态两个特征
- 所谓继承,从生物学的角度来讲,就是儿子继承了父亲的一些特征,例如相貌等,而在面向对象里面的也是差不多的意思,子类继承父类的一些功能和属性,可以被子类重复使用,并且子类拥有自己的功能和属性
- 多态这一特性是为了实现接口重复使用,多态的一大作用是为了解耦,为了解除继承的耦合度,
- 接口的多种不同的实现方式即为多态。同一操作作用于不同的对象，产生不同的执行结果。在运行时，通过指向基类的指针或引用来调用派生类中的虚函数来实现多态,很多的设计模式都是基于面向对象的多态性设计的,如果说封装和继承是面向对象的基础,那么多态是面向对象精髓的部分

## 面向对象的思想和关键词

- 面向过程: 效率高,维护难
- 面向对象: 效率低,维护简单
- 概念:
  - 类: 虚
  - 对象 就是类的实例化
- 关系:
  - 类 就是对象的抽象化
  - 对象 就是类的实例化
  - 一切皆对象
- 定义类:
  - class 类名
  - { 
  - 成员属性(有什么,变量)
  - 成员方法(会什么, 函数)
  - }
- 实例化对象:
  - 变量 = new 类名

### 对象

- 通过对象 来使用属性 
  - 格式: 对象-> 属性名
- 通过对象 来使用方法
  - 格式: 对象-> 方法名()
- 每一次的实例化,都会重新生成一个对象 ,哪怕实例化同一个类,得到的对象都不是一个内存的
- 类内是可以实例化自己的
- 如果是在类内, 通过$this 来代替实例化自己 $this 代表自己的对象
- 类内属性的创建 $this -> 新的属性名=值
- 在一个类中,方法A想要使用方法B的局部变量,只需要方法B 将局部变量变成属性即可
- 连贯操作
  - 格式: 对象-> 方法1()->方法2()->方法3()->方法4()->方法5()....
  - 注意:
    - 前面的方法必须要返回 能调用后面方法的对象才行

## 魔术方法

功能: 再触发执行条件下,自动执行魔术方法

### 1,构造方法

- 修饰符 function __construct()
- 作用: 初始化
- 触发条件: 实例化对象时
- 位置;
  - 属性的最后面,方法的最前面
- 返回值: 不需要返回值

### 2. 析构方法

- 修饰符 function __destruct()
- 作用: 当对象结束时,做的结尾操作
- 触发: 当对象被销毁时,自动触发
  - 常见3种销毁场景:
    - 程序自然结束时
    - 对象变量被 主动删除时
    - 对象变量被覆盖时
- 位置:方法的最后面
- 注意:
  - 不能有参数,也不能有返回值

### 3.__GET 方法

- 修饰符: __GET()当访问非公有属性时或者已经被删除的属性和方法,自动触发,一个参数,访问的哪个东西

### 4.__SET 方法

- 当设置非公有属性时,自动触发,两个参数,设置的属性名,设定的值

### 5.__unset 方法

- 当删除非公有属性时,自动触发,一个参数,想要删除的人

### 6.__isset 方法

- 当检测非公有属性是否设置(为空)时,自动触发

### 7.__call 方法

- 当访问不存在的方法时,自动触发

### 8.__toString方法

- 当输出对象时,自动触发,且必须返回字符串值







## OOP的3大特性

### 封装

- 高内聚: 将对象的全部成员属性和方法集中在一个类里面

- 低耦合: 尽可能隐藏成员属性和方法,只留下部分接口与外部联系

- 作用: 提高代码复用率,安全性

- 封装方法的一些显示

  |  类型  |  修饰符   |  类外  | 类内 |   继承   |
  | :----: | :-------: | :----: | :--: | :------: |
  | 公有化 |  public   |  可用  | 可用 |   可用   |
  | 私有化 |  private  | 不可用 | 可用 |  不可用  |
  | 受保护 | protected | 不可用 | 可用 | 可用继承 |

### 继承

- 定义: 子类继承父类的属性or方法

- 格式:

  - class 子类 extends 父类{

    }

  - 父类: 基类/基础类

  - 子类: 继承类/扩展类/派生类

- 特性:

  - 可继承属性,方法 (私有属性or方法 不能继承)
  - 可重写/扩展属性,方法
  - 在继承时,修饰符 要么保留等级,要么降级
  - private > protected > public
  - 支持单继承,不支持多继承 (一个子类只能继承一个父类)

- 场景:

  - 有多个类
  - 需要使用多个相同的功能时,此时将多个相同的功能集中在父类里面
  - 如果只有一个相同的功能,可以写成函数

- 子类在原先方法上的扩展

  - 需要先调用
  - parent::父类方法名
  - 下面输出自己要扩展功能

### 多态

- 类型约束

  - 数组
    - 格式: 函数名(array 形参名)
  - 对象(普通类/接口类/抽象类/)
    - 格式: 函数名(object/对象名 形参名)
    - 注意: object 只支持PHP5以上版本, 用对象名的话,只支持自己和他的所有子类

- 多态:

  - 通过同一个接口类/抽象类,传入不同的对象,来实现不同的功能

  ```
  # 接口类  
  interface USB 
  {
      public function run()
  }
  
  
  
  # 外部设别
  class Mouse extends USB 
  {
      public function run()
      {
          echo '鼠标的驱动已安装 <br>';
      }
  
  }
  
  class Keyboard extends USB
  {
      public function run()
      {
          echo '键盘的驱动已安装 <br>';
      }
  
      public function other()
      {
          echo '一键弹出钞票 <br>';
      }
  }
  
  
  # 电脑
  class Computer 
  {
      public function start( USB $x )
      {
          $x->run();
      }
  }
  
  
  
  $c = new Computer; # 电脑已就位
  $m = new Mouse;     # 鼠标已就位
  $k = new Keyboard;  # 键盘已就位
  
  
  $c->start($m);
  $c->start($k);
  ```

  ### foreach不仅可以遍历数组还可以遍历对象

## 面向对象的关键词

### 类静态static

1.格式:

​	static 修饰符 属性名

​	修饰符 static 属性名 = 属性值

2.操作:

- 类名::属性名
- 类名: 方法名()
- self 代表当前的类
- $this 代表当前的对象

3.特性

- 可以修饰成员属性,方法
- 静态不需要对象就可以直接使用
- 在静态方法内,只能使用静态属性or 方法
- 静态可以继承

4.魔术

- __callStatic() 
  - 当访问一个不存在的静态方法时,自动触发
  - 本身就是一个静态方法

### 类常量 const

1. 格式
   - const 类常量名 = 常量值
2. 特性
   - 类常量既不是属性,也不是方法
   - 类常量可以继承,且重写一次类常量
   - 在一个类中,只能存在一个同名常量
3. 操作
   - 类名::常量

### 克隆运算符 clone

1. 格式:
   - 对象2 = clone 对象1
2. 特性
   - 对象1 和对象2 完全相同,互不影响,内存独立
3. 魔术方法
   - __clone 当克隆对象时,自动触发 (在克隆时,可重新初始化属性)
   - 真正的克隆魔术方法: 常用于防止别人克隆

### 最终 final 

1. 格式:
   - final class 类名{}
   - final 修饰符 function 方法名(){}
2. 特性
   - 修饰类,被称为最终类,不能被继承
   - 修饰方法,被称为最终方法,不能被重写
3. 作用
   - 保护父类结构

### 抽象 abstract 

1. 格式
   - abstract class 类名{}
   - abstract 修饰符 function 方法名(){}
2. 特性
   - 修饰类,被称为'抽象类'
   - 修饰方法,被称为'抽象方法'
3. 作用
   - 约束,不让使用,必须有子类来完成,否则就不能使用
4. 注意:
   - 抽象类不一定有抽象方法,抽象方法必须在抽象类中

### 接口

1.定义:

- 当抽象类中全部为抽象方法时,即可用接口

2.格式:

- interface 接口类名{

  }

  class 子类 implements 接口类{}

  class 子类 implements 接口类1,接口类2,接口类3

- 注意:

  - 一个接口类只能被一个子类接收
  - 一个子类可以接收多个接口类

3. 实例:

   可以利用这个特性来进行伪多继承

   // 伪多继承

   ```
   interface sum
   {
       public function dream();
   }
   interface sum1
   {
       public function dream2();
   }
   class Sons implements sum,sum1
   {
       public function dream()
       {
           echo '我想去旅游';
       }
       public function dream2()
       {
           echo '我想去遍天地';
       }
   }
   $b = new Sons;
   $b->dream();
   $b->dream2();
   ```

   

### instanceof滴血认亲 (运算符)

- 检测是否是从某类实例化过来的
- 检测是否是从 某类 继承过来的
- 格式:
  - 对象A instanceof 对象B
  - 对象A instanceof 对象B

### 串行化/序列化

1. 作用:
   - 将对象转化为字符串
   - 为了可以实现页面传输,存入数据库
   - 存入文本等
2. 函数: 
   - serialize() 串行化 将对象->字符串
   - unserialize() 反串行化 将字符组->对象
3. 魔术方法:
   - 串行化时,__sleep()返回值:只返回自己想要展示的,其他的不展示
   - 反串行化时,__wakeup()唤醒时重新初始化属性

### autoload 自动加载 (魔术方法)

自动加载 (魔术方法)
    1.触发条件: 当实例化一个不存在的类时,自动触发

```
2.好处:
    当需要实例化多个不同的类时,且类不在当前页面中可通过"自动加载"按需加载相关的类文件
项目潜规则:
    * 一个文件只能含有一个类
    * 类名与类文件夹名 使用 大驼峰,命名法
    * 类名 与 类文件名必须有关联
```

function load($x)
{
    if(file_exists("./Lib/{$x}.php")){
        include_once "./Lib/{$x}.php";
    }else{
        header('location:./404/index.html');
        die;
    }
}
spl_autoload_register('load');

$a = new Upload;
$b = new DB;
$c = new Image;

### 

## PDO(一个类,主要链接执行数据库)

- 作用:
  - 主要目的链接数据库,可以链接不同的数据库操作系统

### PDO方法

- 构造方法,实例化来链接数据库

  - __constuct($dsn,$user,$password)

    - $dsn: 选择哪种数据库类型,主机名,要选择的数据库,字符编码
    - $user: 数据库用户名
    - $password: 数据库密码
    - $dsn = 'mysql:host=localhost;dbname=wjh;charset=utf8'

    $a = new PDO($dsn,$user,$password)

- 执行方法:

  - PDO::query(sql查询语句) 返回一个结果集对象
  - PDO::exec(sql增删改语句) 返回受影响的行数
  - PDO::lastInsertId()无参数,获取最后一次插入的id
  - PDO:: errorInfo()获取最后一次的sql错误信息

- 结果集方法(PDOStatement):

  - PDOStatement::fetch() 从结果集中获取一条数据,一维数组
    - 参数: PDO::FETCH_ASSOC	返回一维关联数组
  - PDOstatement::fetchall()从结果集中获取全部数据,二维混合数组
    - 参数: PDO::FETCH_ASSOC	返回二维关联数组

## 面向对象的函数

- 检测类是否存在 class_exists(类)
- 检测属性是否存在 property_exists(类,属性)
- 获取类中的所有属性 get_class_vars(类)
- 获取对象中的所有属性 get_object_vars(对象)
- 获取类中的所有方法 get_class_methods(类)
- 获取对象的类名 get_class(对象)

## 异常结构

try

{

捕获异常

- 自动: 违反PHP解释器的规则,常规出错
- 主动: 违反人为逻辑设定
  - throw new Exception('报错信息',10086),人为设定

}catch( Exception $e ){ Exception 异常类,处理异常

报错内容

- $e->getMessage()错误原因
- $e->getFile()错误文件
- $e->getLine()错误行号
- $e->getCode()错误编号

}

运行方式: 先在 捕获区域捕获异常, 一旦捕获成功,则立马跳转至catch 进行处理

## 事务

1. 事务

   - 将 多条SQL 语法绑定为一条整体,只有全部成功才算成功,其中有任意一条ssql 出错,则整体出错

2. 事务支持

   - MyISAM 不支持事物性
   - InnoDB 支持事务

3. 自动提交

   - MySql 默认情况,都是开启自动提交 ( 一旦执行sql,数据库就会立马改变 )
   - 事务一般会提前关闭自动提交
   - 什么时候开启提交
     - 当事务结束时
     - 事务执行成功时,会主动提交sql

4. 操作事物

   - 关闭自动提交
     - PDO::setAttribute(PDO::ATTR_AUTOCOMMIT,0);
   - 开启一个事务
     - PDO::beginTransAction();
   - 正常操作SQL业务
     - 成功: 主动提交事务
       - PDO::commit()
     - 失败: 回滚事务,回到最初的状态
       - PDO::rollBack()
   - 开启自动提交
     - PDO:: setAttribute(PDO::ATTR_AUTOCOMMIT,1)

   ```php
    链接数据库
   try {
       # 捕获异常 
       $dsn = 'mysql:dbname=s89;host=localhost;charset=utf8';
       $user = 'root';
       $pwd = '';
       # 自动抛出异常
       $pdo = new PDO( $dsn, $user, $pwd );
   } catch (Exception $e) {
       # 处理异常
       echo '链接数据库失败 <br>';
       echo '原因: '.$e->getMessage().'<br>';
       echo '错误文件: '.$e->getFile().'<br>';
       echo '错误行号: '.$e->getLine().'<br>';
       echo '错误编号: '.$e->getCode().'<br>';
   }
   
   
   try {
       # 1. 关闭自动提交
       $pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 0);
   
       # 2. 开启一个事务
       $pdo->beginTransAction();
   
       # 3. sql业务
           # 3.1 -1000
           $sql = "UPDATE salary SET money = money - 1000 WHERE id = 3";
           $rows = $pdo->exec($sql);
           if(!$rows){
               throw new Exception('资金转出失败');
           }
   
           # 3.2 +1000  
           $sql = "UPDATE salary SET money = money + 1000 WHERE id = 6";
           $rows = $pdo->exec($sql);
           if(!$rows){
               throw new Exception('资金转入失败');
           }
   
           # 提交事务
           $pdo->commit();
   
   } catch (Exception $e) {
       
       # 提示错误信息
       echo $e->getMessage();
   
       # 回滚事务
       $pdo->rollBack();
   }
   
   
   # 4. 开启自动提交
   $pdo->setAttribute(PDO::ATTR_AUTOCOMMIT, 1);
   ```

## 单例设计模式

1.定义:

- 保证只有一个实例

2.特性:

- 只有一个实例
- 自己创建自己
- 必须要返回实例,供给别人使用

```
class MySQL
{
    static private $link = null;

    private function __construct()
    {
        echo '数据库已连接 <br>';
    }


    static public function getConnect()
    {
        # 如果$link 为null, 则证明从没有new过, 那么new一次
        # 如果$link 不是null, 则证明曾经new过, 那么跳过new
        if (  self::$link === null ) {
            self::$link = new self;
        }

        # 返回当前的对象, 供给别的变量使用
        return self::$link;
    }

}


// $a = new MySQL;
// $b = new MySQL;
// $c = new MySQL;
// var_dump($a, $b, $c);


$a = MySQL::getConnect();
$b = MySQL::getConnect();
$c = MySQL::getConnect();

var_dump($a, $b, $c);
```












































