
> 世界上最难懂的四件事： (╯▽╰ )
> 1. 道士的符文
> 2. 医生的处方
> 3. 女人的心
> 4. 程序员的正则

---
layout: post
title: '正则表达式笔记'
date: 2019-11-06
categories: test
tags: regex
---

## 1. 正则简介

### 简介

正则表达式（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些符合某个模式的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。

### 历史

1940 年，Warren McCulloch（沃伦.麦卡洛克）与 Walter Pitts（沃尔特.皮茨）这两位神经生理方面的科学家，研究出了一种用数学方式来描述神经网络的新方法.将神经系统中的神经元描述成小而简单的自动控制元。

1950 年，数学家 Stephen Kleene（斯蒂芬·克莱尼）利用称之为“正则集合”的数学符号来描述此模型。

之后，Unix 之父：Ken Thompson（肯·汤普逊）将此符号系统引入编辑器 QED，随后是 Unix 上的编辑器 ed，并最终引入 grep。自此以后，正则表达式被广泛地应用于各种 Unix 或类 Unix 系统的工具中。

现在，你会在主流操作系统（Linux， Unix、Windows、HP、BeOS等）、主流的开发语言
（delphi、Scala、PHP、C#、Java、C++、Objective-c、Swift、VB、Javascript、Ruby以及Python等）、数以亿万计的各种应用软件中，都可以看到正则表达式的身影。

----

### 定义及用途

- 正则表达式也叫`模式表达式`
- 正则配合特定的函数，可实现字符串的匹配、查找、替换、分割等操作。
- 正则本质上也是一个字符串。
- 常见的正则用途：匹配手机号，邮箱验证，日期，帐号密码格式。

----

## 2. PHP正则的基本知识

> 在PHP程序中，正则表达式必须配合`正则处理函数`才能使用。
>
> PHP中支持正则表达式的处理函数是由`PCRE`库提供的，使用`preg_`作为前缀。

| `PCRE`库正则表达式函数   | 功能说明                                 |
| ----------------------- | ------------------------------------ |
| preg_match()            | 执行正则表达式匹配                   |
| preg_match_all()        | 执行全局正则表达式匹配               |
| preg_replace()          | 执行正则表达式的搜索和替换           |
| preg_split()            | 用正则表达式分割字符串               |
| preg_grep()             | 返回与模式匹配的数组单元             |
| preg_replace_callback() | 用回调函数执行正则表达式的搜索和替换 |

> 准备测试代码:

```php
$str = '此处输入要匹配的字符串';
$regExp = '此处提供正则表达式';

// 匹配验证
if ( preg_match($regExp, $str, $arr) ) {
    echo '正则表达式:
        <font size="5" color="#00f">' . $regExp . '</font><br>
        匹配字串:
        <font size="5" color="#00f">' . $str . '</font><hr>
        匹配结果:
        <font size="5" color="#0a0">成功</font><br>';

    echo '<pre>';
    print_r($arr); // 输出匹配到的结果
    echo '</pre>';
} else {
    echo '正则表达式:
        <font size="5" color="#00f">' . $regExp . '</font><br>
        匹配字串:
        <font size="5" color="#00f">' . $str . '</font><hr>
        匹配结果:
        <font size="5" color="#f00">失败</font><br>';
}
```

> PS. 测试正则
- [在线工具](https://tool.lu/regex/)
- [在线正则表达式测试](http://tool.oschina.net/regex/)
- [正则表达式工具 Match Tracer](http://www.regexlab.com/zh/mtracer/)

----

## 3. 正则语法规则

PHP中的正则表达式，由四部分构成：

- 定界符
- 原子
- 元字符
- 模式修正符

> 一个最简单的正则，至少要包含`定界符`和`一个原子`。

### 1. 定界符

每个正则表达式 都必须要有`一对定界符`。

除了数字、字母、反斜线以外的任意一个字符，都可以用来做为正则表达式的定界符。

如：`~!@#$%^&*_+:;<>.?|/ () {} []`，推荐使用 `/`

----

### 2. 原子

> 原子是组成正则表达式的最小单位，`一个原子 匹配 一个字符`。

#### 2.1 普通字符

`数字、字母、下划线： 0~9 a~z A~Z _`

#### 2.2 特殊字符

`'' "" / . * + ? | () [] & ^ \`

> 某些特殊字符 在正则里具有特殊意义，匹配此类字符时，
> 需要在正则里 使用反斜线 `\` 来转义，将其变成普通的原子

#### 2.3 非打印字符

```
\f  --  匹配 分页符
\r  --  匹配 回车符
\n  --  匹配 换行符
\t  --  匹配 制表符
\v  --  匹配 垂直制表符
```

#### 2.4 通用字符类型

```
\d  --  匹配 任意一个十进制数字[0~9]
\D  --  匹配 任意一个十进制数字以外的字符

\s  --  匹配 任意一个空白字符 [空格 tab \f\r\n\t\v]
\S  --  匹配 任意一个除了空白字符以外的字符

\w  --  匹配 任意一个数字/字母/下划线 [0~9 a~z A~Z _]
\W  --  匹配 除数字/字母/下划线以外的任意一个字符
```

#### 2.5 原子表

> 用`[]`中括号来表示 自定义的原子，依旧是只匹配一个字符。

```
[abc]   --  匹配 原子表中的 任意一个字符
[^abc]  --  匹配 除表内原子以外的 任意一个字符

另外，在原子表中可以使用 -（减号），来连接一组 ASCII 码顺序排列的原子。
[a-z]  --  匹配 从 a 到 z 的任意一个字母
```

----

### 3. 元字符

> 用来修饰其前面的`原子`出现的 `次数` 或 `位置`
>
> 元字符不能单独出现，它必须是用来修饰原子的。

#### 3.1 限定符

> 用来指定 前面的一个原子 出现多少次 才能满足匹配

```
*      --  匹配 其前面的一个原子 0次 1次 多次(任意多次)
+      --  匹配 其前面的一个原子 1次 多次(至少一次)
?      --  匹配 其前面的一个原子 0次 1次
{n}    --  匹配 其前面的一个原子 正好 n 次
{n,}   --  匹配 其前面的一个原子 至少 n 次
{n,m}  --  匹配 其前面的一个原子 至少 n 次，最多 m 次
```

#### 3.2 边界限制

```
^ 或 \A  --  匹配 字符串 开始的位置，表示必须以 某个字符串开头
$ 或 \Z  --  匹配 字符串 结束的位置，表示必须以 某个字符串结束

\b       --  匹配 单词边界
\B       --  匹配 非词边界，除单词边界以外的部分
写在前，就是限定该单词的前方，写在后，就是限定后方
```

#### 3.3 句号

`.` 匹配 任何一个字符，除了换行符(\n)。

#### 3.4 模式单元

`()` 把括号中的内容当成一个整体，当作一个大原子。
> () 内标记的原子，也叫做子模式。

#### 3.5 模式选择符

`|` 在多个模式之间，选择匹配到的那一个。

匹配是从左至右执行的，所以`容易`匹配的值放`右边`；`不易`匹配到的放`左边`。

#### 3.6 后向引用

```
\1  \2  \3     --  匹配 第1个、第2个、第3个 子模式的内容
\\1  \\2  \\3  --  匹配 第1个、第2个、第3个 子模式的内容(转义\)
```

用`()`标记的原子是一个子模式，也是一个独立的单元，所有子模式匹配的内容，都会被储存在临时缓存区，以被后用。

缓存区编号规则是：
从左向右，以左括号为 缓存标志，从 1 开始，连续编号，最大至 99 个子表达式。
每个缓存区都可以使用`\1`或`\\1`的形式去访问。

> 非捕获模式（忽略匹配）
>
> 当需要用到 模式单元，又不想存储 某个匹配子模式时，
>
> 可使用 非捕获元字符 `(?:)` 来忽略子模式的匹配。
>
> (?:pattern) 
> 非获取匹配，匹配pattern但不获取匹配结果，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。
> (?=pattern)
> 非获取匹配，正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配“Windows2000”中的“Windows”，但不能匹配“Windows3.1”中的“Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。
> (?!pattern)
> 非获取匹配，正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串，该匹配不需要获取供以后使用。例如“Windows(?!95|98|NT|2000)”能匹配“Windows3.1”中的“Windows”，但不能匹配“Windows2000”中的“Windows”。
> (?<=pattern)
> 非获取匹配，反向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。
> (?<!pattern)
> 非获取匹配，反向否定预查，与正向否定预查类似，只是方向相反。例如“(?<!95|98|NT|2000)Windows”能匹配“3.1Windows”中的“Windows”，但不能匹配“2000Windows”中的“Windows”。这个地方不正确，有问题 

----

### 4. 模式修正符

> 模式修正符 必须放在正则表达式之外使用。(右定界符之后)
>
> 它是用来扩展 正则的某些功能。
>
> 模式修正符可以组合使用。

````
i  --  不区分大小写
m  --  视为多行
s  --  视为一行
x  --  模式中的空白忽略不计，除非已经被转义
U  --  非贪婪模式(默认为贪婪模式)
````

----

## 模式匹配的优先级

```
\
()  (?:)  (?=)  []
*  +  ?  {n}  {n,}  {n,m}
^  $  \b  \B  \A  \Z
|
```

----

# PS. 回车和换行(CR/LF)

“回车”（carriage return）VS  “换行”（line feed）

在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的玩意，每秒钟可以打 10 个字符。但是它有一个问题，就是打完一行换行的时候，要用去 0.2 秒，正好可以打两个字符。要是在这 0.2 秒里面，又有新的字符传过来，那么这个字符将丢失。

于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界；另一个叫做“换行”，告诉打字机把纸向下移一行。

这就是“换行”和“回车”的来历，后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。

Unix 系统里，每行结尾只有“<换行>”，即`\n`；Windows 系统里面，每行结尾是“<换行><回车>”，即`\n\r`；Mac 系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac 系统下的文件在 Windows 里打开的话，所有文字会变成一行；而 Windows 里的文件在 Unix/Mac 下打开的话，在每行的结尾可能会多出一个`^M`符号。

关于换行符:
- 在文本处理中，`CR`，`LF`，`CR/LF`是不同操作系统上使用的换行符.
- Dos 和 windows 采用回车+换行`CR/LF`表示下一行，
- 而 UNIX/Linux 采用换行符`LF`表示下一行，
- 苹果机(MAC OS系统)则采用回车符`CR`表示下一行.

为什么不同:
- `CR`用符号`\r`表示， 十进制 ASCII 代码是`13`， 十六进制代码为`0x0D`;
- `LF`使用`\n`符号表示， ASCII 代码是`10`， 十六制为`0x0A`.
- Windows 平台上换行在文本文件中是使用 `0d` `0a` 两个字节表示，
- UNIX 和苹果平台上换行则是使用`0a`或`0d`一个字节表示.

一般操作系统上的运行库会自动决定文本文件的换行格式。 如一个程序在 windows 上运行就生成 CR/LF 换行格式的文本文件，而在 Linux 上运行就生成LF格式换行的文本文件。

在一个平台上使用另一种换行符的文件文件可能会带来意想不到的问题， 特别是在编辑程序代码时。 有时候代码在编辑器中显示正常， 但在编辑时却会因为换行符问题而出错。
